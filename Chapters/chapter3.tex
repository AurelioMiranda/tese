%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter3.tex
%% NOVA thesis document file
%%
%% Challenges and requirements to build the DSL
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\chapter{Challenges and Requirements for a Configurable Code Generator}
\label{chap:challenges_and_requirements}

\epigraph{
	The ability to generate code is no longer sufficient: the code must be understandable, auditable, integrable, and compliant with a spectrum of project-specific requirements. This chapter delves into why configurability is no longer optional, and how traditional code generation pipelines must evolve.
}

\section{The Inflexibility of RAMSES: A Barrier to Industrial Integration}
\label{sec:inflexibility_ramses}

RAMSES has served as a robust model-to-code generator for AADL-based systems, yet it suffers from a fundamental architectural constraint: it assumes a uniform target environment. This assumption does not hold in real-world industrial projects, where system heterogeneity, legacy integration, and domain-specific standards define a constantly shifting context.

The core issue lies in RAMSES’ transformation pipeline: it entangles policy decisions (e.g., naming, structure, integration style) with generation logic. These decisions, hardcoded in ATL transformations, reflect the assumptions of RAMSES' authors more than the needs of downstream consumers. Altering them involves modifying the transformation source itself — often a non-trivial and error-prone task.

Consider a simple use case: a company mandates that all task-level functions use `snake\_case` and include a `COMPONENT\_` prefix. RAMSES, which might generate `ComputeTask` by default, offers no out-of-the-box way to enforce such rules. A change in naming becomes a traversal through ATL templates and helpers. This is not scalable, and in safety-critical software, it is not acceptable.

Furthermore, beyond naming, decisions about memory allocation models, system initialization flows, and error handling behaviors are equally rigid. There is no declarative layer that allows users to steer generation outcomes according to organizational needs or evolving constraints. As such, RAMSES provides code generation but not code governance.

\section{Industrial Realities and Pressures}
\label{sec:industrial_realities}

To understand why this rigidity is problematic, we must shift perspective from the generator to the organization that consumes it. In industry, generated code is not ephemeral: it is versioned, peer-reviewed, statically analyzed, tested, and in some cases certified. It coexists with handwritten code, interfaces with platform-specific services, and must evolve alongside requirements.

\subsection*{Compliance, Traceability, and Certification}

Generated code must often comply with domain-specific standards such as:

\begin{itemize}
	\item \textbf{MISRA C/C++:} Imposes constraints on memory usage, naming, control flow, and portability~\cite{Misra_C_2025}~\cite{Misra_Cpp_2023}.
	\item \textbf{DO-178C:} Requires traceability, tool qualification, and clear derivation from high-level requirements. 
	\item \textbf{ISO 26262:} Enforces safety-related development practices and documentation.
\end{itemize}

In these environments, code generation must do more than “just work.” It must be explainable, auditable, and deterministic. Developers must be able to trace a generated function back to a model element and forward to a specific runtime behavior.

\subsection*{Integration with Legacy Codebases}

Most industrial systems are not built from scratch. Code generators must work alongside:

\begin{itemize}
	\item Legacy libraries with non-negotiable APIs.
	\item Hardware abstraction layers that impose structural patterns.
	\item Existing software architecture rules (how modules communicate, how tasks are organized).
\end{itemize}

A code generator that cannot adapt to these constraints is often sidelined in favor of manual glue code or post-processing scripts. These scripts, in turn, introduce maintainability challenges and break traceability chains.

\subsection*{Developer Ergonomics and Maintenance}

Even the most advanced generator will eventually produce code that is read (and possibly modified) by a human developer. 

\begin{tcolorbox}[colback=green!8]
	If developers can’t read or rely on the generated code, they’ll stop trusting it altogether.
\end{tcolorbox}

Poor formatting, ambiguous naming, or surprising control flow all reduce the utility of generated artifacts, leading teams to “lock” generated files and prohibit modifications: an anti-pattern that defeats the promise of model-driven engineering.

\section{Why Configuration Matters}
\label{sec:why_configuration_matters}

To resolve the issues above, we must introduce a new abstraction layer: one that separates \textbf{what} is generated from \textbf{how} it is generated. This is the role of a configuration language.

A configuration language provides a structured way to express \textbf{generation policy}: the set of rules, conventions, and constraints that tailor code to its industrial context. Importantly, it allows these policies to be:

\begin{itemize}
	\item \textbf{Externalized} from the transformation logic.
	\item \textbf{Composable} and layered across project variants.
	\item \textbf{Validated} for correctness before code generation begins.
\end{itemize}

Such language enables a fundamental shift: from a monolithic, one-size-fits-all generator, to a configurable and extensible platform that adapts to its environment.

\section{Characteristics of an Effective Configuration Layer}
\label{sec:config_language_characteristics}

Designing this kind of language is challenging. It needs to balance expressiveness, ease of use, and seamless integration. Based on industrial feedback and analysis of RAMSES’ shortcomings, the following characteristics are proposed:

\subsection*{1. Declarative, Not Imperative}

Users should describe \textbf{what} they want (e.g., “all functions must use snake\_case”) rather than \textbf{how} to achieve it. This aligns with the model-driven philosophy and supports better static analysis.

\subsection*{2. Human-Readable and Tool-Accessible}

The configuration format (proposed DSL) should work well with version control, support difference review, and remain readable to engineers. It must also be machine-readable for validation and generation.

\subsection*{3. Modular and Hierarchical}

Configurations should support reuse and composition. For example, a company-wide `default\_config` can be extended by a project-specific override. Inheritance models must be explicit and predictable. (review this********************)

\subsection*{4. Aligned with Modeling Concepts}

To maintain semantic coherence, configuration keys should refer to modeling elements (e.g., `thread`, `port`, `data component`) and not generator internals.

\subsection*{5. Validated and Error-Tolerant}

Invalid configurations should produce clear diagnostics before generation starts. Where possible, defaults and fallbacks should be available to prevent blocking workflows.

\section{Beyond Code Formatting: What Configuration Should Control}
\label{sec:config_scope}

While naming and formatting are important, a powerful configuration system must go further. The following dimensions should be within scope:

\begin{enumerate}
	\item \textbf{Artifact Naming and Structuring:} Control over file names, folder layout, and identifier styles.
	\item \textbf{Component Mapping Rules:} Declarative rules that assign AADL components to target platform concepts (RTOS tasks, processes, etc).
	\item \textbf{Code Instrumentation:} Hooks for logging, tracing, or runtime checks (insertion of `assert` or instrumentation macros).
	\item \textbf{Conditional Feature Flags:} Ability to enable or disable parts of the generator (generate test stubs, insert HAL wrappers).
	\item \textbf{Toolchain-Specific Directives:} Integration of compiler pragmas, section attributes, or OS-specific macros.
\end{enumerate}

\begin{tcolorbox}[colback=blue!5, colframe=blue!50!black, title=Configuration is More Than Style]
	While formatting is the most visible aspect of configurability, its true value lies in controlling semantic properties of the generated code: platform binding, integration, traceability, and lifecycle.
\end{tcolorbox}

\section{Proof of concept}
\label{sec:proof_of_concept}

In order to better understand the whole concept of the DSL to be built during this thesis, a prototype that encompasses the logic of the 


\section{Toward a Generator for System Integrators}
\label{sec:conclusion_configurable_generation}

RAMSES has proven to be a robust and effective tool for model-to-code generation, particularly within academic contexts and controlled environments. However, as embedded systems development increasingly intersects with regulatory and industrial demands, the expectations placed on code generators have grown. Beyond correctness, they must now offer adaptability, traceability, and long-term maintainability to meet evolving project requirements.

Introducing a configuration language is not merely a feature, it's an architectural shift. It allows users to define their generation context without touching generator internals, reducing risk, increasing reuse, and enabling automation across product lines.

The next chapter will formalize this idea by designing a configuration language tailored to RAMSES. The goal: decouple transformation logic from project policy and pave the way for truly industrial-scale model-driven code generation.


