%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter7.tex
%% NOVA thesis document file
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter7.tex}%

\chapter{Conclusion and Future Work}
\label{cha:conclusion}

\epigraph{ \textit{What did we ultimately learned, and what comes next.}}

This chapter concludes the dissertation by summarizing the research efforts and the results obtained throughout the project. It revisits the primary challenges identified regarding the rigidity of \gls{RAMSES} in industrial contexts, such as industrial naming conventions and legacy integration requirements, and evaluates how the design and implementation of the Configuration \gls{DSL} successfully address these limitations. The chapter concludes by outlining directions for future work aimed at extending the scope, scalability, and industrial applications of the developed solution.

\section{Conclusion}
\label{sec:concl}

The automatic generation of code for safety-critical embedded systems offers immense potential for reducing costs and errors. However, tools like \gls{RAMSES} have historically suffered from rigidity. Prior to this work, integrating \gls{RAMSES} into a \gls{ROS} workflow required post generation scripts or manual coding, breaking the traceability chain. This can limit \gls{RAMSES} the adoption in industrial environments where coding standards, legacy integration, and specific middleware configurations are not negotiable.

This dissertation presented the design, implementation, and validation of a Configuration \gls{DSL} for \gls{RAMSES} that directly addresses these limitations. By externalizing generation policies into a dedicated configuration layer, this approach enables developers to customize code generation behavior without modifying the internal transformation logic of the generator. This architectural separation preserves the integrity of the \gls{M2T} transformation while introducing the flexibility required by industrial workflows.

Key contributions of this work include:

\begin{itemize} 
	\item \textbf{A Robust Configuration Language: } A \gls{DSL} capable of defining naming conventions, file management strategies, and documentation standards. Which eliminates the need for manual renaming of identifiers to match C++ snake\_case vs PascalCase requirements, for example.
	
	\item \textbf{Architectural Flexibility: } The ability to decouple business logic from the \gls{ROS} and select specific threading models (Executors). That allows the core business logic to be reused in non-\gls{ROS} contexts or ported to different middleware with minimal effort.
	
	\item \textbf{Enhanced Traceability: } The automated generation of \gls{JSON} trace files and \gls{HTML} reports that link high-level \gls{AADL} models to low-level C++ artifacts, facilitating auditability. While this added ~250ms of generation time (Section~\ref{sec:exec_times}), it provides critical audit trails for safety certification (DO-178C/\gls{ISO} 26262)."
	
	\item \textbf{Seamless Integration: } A user-friendly preference store implementation within the Eclipse environment that abstracts the complexity of the underlying metamodels. Which allowed even non-expert users (P2, P3) to configure the generator with a low error rate during validation (Section~\ref{sec:test_usabl_participant_character})."
\end{itemize}

This work effectively removes a major barrier to the industrial adoption of \gls{RAMSES}, directing the way for its use in complex, heterogeneous cyber-physical systems.


\section{Future Work}
\label{sec:concl_future_work}

While this dissertation establishes a solid foundation for configurable code generation in \gls{RAMSES}, several options for future research and development remain. The focus of the \gls{DSL} usage being C++ and \gls{ROS} prioritized certain features over others and the limited sample size, although enough to prove that the software works as intended and is very much usable, should be a point to tackle when the final version of \gls{RAMSES} is available.



\subsection{Expansion of Supported Standards and Languages}
\label{sec:concl_language_and_standard_expansion}

Currently, the configuration language focuses on C++ with a strong emphasis on \gls{ROS}. Future iterations should expand this to support:

\begin{itemize} 
	\item \textbf{Additional Languages: } Support for C, Ada or Rust, which are increasingly relevant in safety-critical domains. This would require extending the 'Language' Ecore class and implementing new Acceleo templates that respect the specific memory safety models of Rust or the strict typing of Ada.
	
	\item \textbf{\gls{AUTOSAR} Integration: } Implementing specific configurations to support the \gls{AUTOSAR} standard, making \gls{RAMSES} a viable alternative in the automotive industry. This involves mapping \gls{AADL} ports to \gls{AUTOSAR} interfaces, a complex transformation currently only partially supported by commercial tools since it is specific to the \gls{AUTOSAR} workflow and must be present in any tool using \gls{AUTOSAR}.
	
	\item \textbf{Deep \gls{MISRA} Enforcement: } Integrating stricter, configurable \gls{MISRA} rule sets directly into the generation logic rather than relying solely on post-generation static analysis. Generative compliance is superior to post analysis as it guarantees correct code from the get go, reducing the validation loop.
\end{itemize}



\subsection{Graphical Configuration Interface}
\label{sec:concl_g_c_interface}

Currently, the configuration is handled via a dropdown-based preference menu. Developing a graphical, diagrammatic representation of the configuration (using Sirius) could make the relationships between configurations (such as inheritance or component-specific overrides) more intuitive for non-technical users. The usability study (Section~\ref{sec:test_val}) noted that navigation errors were the most common issue for novice users. A graphical view could mitigate this by visualizing the configuration hierarchy.

Such a representation would further reduce the cognitive load associated with complex configurations and support scalability as the number of configurable features grows.



\subsection{Enhanced Traceability and Round-Trip Engineering}
\label{sec:concl_trace}

The current traceability is unidirectional (Model to Code). Future work could explore:

\begin{itemize} 
	\item \textbf{Bidirectional Traceability: } Allowing changes in the configuration or code annotations to reflect back onto the model. This is critical for 'DevOps' workflows where developers might tweak parameters in the code. Ensuring that the model remains the single source of truth requires automated back propagation.
	
	\item \textbf{Visual Trace Diagrams: } The architecture currently supports the data structures required for Visual Trace Diagrams, laying the groundwork for the generation of visual graphs linking model requirements to code artifacts. 
\end{itemize}



\subsection{Large-Scale Industrial Piloting}
\label{sec:concl_industrial_piloting}

To further validate the scalability of the solution, a long-term pilot study with an industrial partner should be conducted. This would involve using the configuration language in a live production environment to assess its impact on maintenance cycles and developer productivity over an extended period.

Future studies should measure the reduction in 'glue code' lines written manually and the time saved during version upgrades of the target middleware (for instance, upgrading \gls{ROS} versions).

Such a study would provide quantitative evidence of long term benefits and serve as a decisive step toward full industrial qualification of the proposed approach.







