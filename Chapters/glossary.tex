%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% glossary.tex
%% NOVA thesis document file
%%
%% Glossary definition
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE glossary.tex}%

\newglossaryentry{JSON}{
  name={JSON},
  sort={JSON},
  description={JavaScript Object Notation is a lightweight data-interchange format. It is easy for humans to read and write. It is easy for machines to parse and generate.}
}

\newglossaryentry{AADL}{
name={AADL},
sort={Architecture Analysis and Design Language},
description={Architecture Analysis and Design Language is a textual and graphical language that can be used to design and analyze the software and hardware architecture of performance-critical real-time systems.}
}

\newglossaryentry{API}{
name={API},
sort={Application Programming Interface},
description={Application programming interface (API) is a connection between computers or between computer programs. It is a type of software interface, offering a service to other pieces of software.}
}

\newglossaryentry{CPS}{
name={CPS},
sort={Cyber-Physical Systems},
description={Cyber-physical systems are mechanisms controlled and monitored by computer algorithms, tightly integrated with the internet and its users. In cyber-physical systems, physical and software components are deeply intertwined, able to operate on different spatial and temporal scales, exhibit multiple and distinct behavioral modalities, and interact with each other in ways that change with context.}
}

\newglossaryentry{DSL}{
	name={DSL},
	sort={Domain-Specific Language},
	description={Domain-specific language (DSL) is a computer language specialized to a particular application domain. Its created specifically to solve problems in a particular domain and is not intended to be able to solve problems outside of it (although that may be technically possible).}
}

\newglossaryentry{M2T}{
name={M2T},
sort={Model-To-Text},
description={Model-to-Text (M2T) is a form of model transformation where structured models are automatically converted into textual artifacts, such as source code, configuration files, or documentation.}
}

\newglossaryentry{JUnit}{
	name={JUnit},
	sort={JUnit},
	description={JUnit is a test automation framework for the Java programming language. JUnit is often used for unit testing, and is one of the xUnit frameworks.}
}

\newglossaryentry{XML}{
name={XML},
sort={XML},
description={XML markup language and file format for storing, transmitting, and reconstructing data. It defines a set of rules for encoding documents in a format that is both human-readable and machine-readable.}
}

\newglossaryentry{identifier}{
name={Identifier},
sort={identifier},
description={A symbolic name used in programming languages to uniquely designate elements such as variables, functions, classes, or types. Identifiers allow programmers to reference and manipulate these entities in code. Their form is subject to the syntactic rules of the language (e.g., starting with a letter or underscore, excluding reserved keywords).}
}

\newglossaryentry{metamodel}{
name={metamodel},
sort={metamodel},
description={A model that defines the structure, semantics, and constraints of other models. In model-driven engineering, a metamodel specifies the types of elements and relationships that can appear in a model, effectively defining the modeling language. For example, an UML metamodel defines what a "Class", "Attribute" or "Operation" is and how they relate.}
}

\newglossaryentry{AAXL2}{
name={AAXL2},
sort={AAXL2},
description={AADL XML version 2 is the XML-based serialization format used by OSATE to store and exchange instantiated AADL models. It represents the fully elaborated instance model resulting from resolving all specifications in an AADL model. AAXL2 files are generated by OSATE during model instantiation and serve as an intermediate representation for analysis and tooling.}
}







